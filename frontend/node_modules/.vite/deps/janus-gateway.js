import "./chunk-UXIASGQL.js";

// node_modules/janus-gateway/npm/dist/janus.es.js
var Janus = function(factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory();
  } else if (typeof window === "object") {
    return factory();
  }
}(function() {
  Janus2.sessions = /* @__PURE__ */ new Map();
  Janus2.isExtensionEnabled = function() {
    if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
      return true;
    }
    if (window.navigator.userAgent.match("Chrome")) {
      let chromever = parseInt(window.navigator.userAgent.match(/Chrome\/(.*) /)[1], 10);
      let maxver = 33;
      if (window.navigator.userAgent.match("Linux"))
        maxver = 35;
      if (chromever >= 26 && chromever <= maxver) {
        return true;
      }
      return Janus2.extension.isInstalled();
    } else {
      return true;
    }
  };
  var defaultExtension = {
    // Screensharing Chrome Extension ID
    extensionId: "hapfgfdkleiggjjpfpenajgdnfckjpaj",
    isInstalled: function() {
      return document.querySelector("#janus-extension-installed") !== null;
    },
    getScreen: function(callback) {
      let pending = window.setTimeout(function() {
        let error = new Error("NavigatorUserMediaError");
        error.name = 'The required Chrome extension is not installed: click <a href="#">here</a> to install it. (NOTE: this will need you to refresh the page)';
        return callback(error);
      }, 1e3);
      this.cache[pending] = callback;
      window.postMessage({ type: "janusGetScreen", id: pending }, "*");
    },
    init: function() {
      let cache = {};
      this.cache = cache;
      window.addEventListener("message", function(event) {
        if (event.origin != window.location.origin)
          return;
        if (event.data.type == "janusGotScreen" && cache[event.data.id]) {
          let callback = cache[event.data.id];
          delete cache[event.data.id];
          if (event.data.sourceId === "") {
            let error = new Error("NavigatorUserMediaError");
            error.name = "You cancelled the request for permission, giving up...";
            callback(error);
          } else {
            callback(null, event.data.sourceId);
          }
        } else if (event.data.type == "janusGetScreenPending") {
          window.clearTimeout(event.data.id);
        }
      });
    }
  };
  Janus2.useDefaultDependencies = function(deps) {
    let f = deps && deps.fetch || fetch;
    let p = deps && deps.Promise || Promise;
    let socketCls = deps && deps.WebSocket || WebSocket;
    return {
      newWebSocket: function(server, proto) {
        return new socketCls(server, proto);
      },
      extension: deps && deps.extension || defaultExtension,
      isArray: function(arr) {
        return Array.isArray(arr);
      },
      webRTCAdapter: deps && deps.adapter || adapter,
      httpAPICall: function(url, options) {
        let fetchOptions = {
          method: options.verb,
          headers: {
            "Accept": "application/json, text/plain, */*"
          },
          cache: "no-cache"
        };
        if (options.verb === "POST") {
          fetchOptions.headers["Content-Type"] = "application/json";
        }
        if (typeof options.withCredentials !== "undefined") {
          fetchOptions.credentials = options.withCredentials === true ? "include" : options.withCredentials ? options.withCredentials : "omit";
        }
        if (options.body) {
          fetchOptions.body = JSON.stringify(options.body);
        }
        let fetching = f(url, fetchOptions).catch(function(error) {
          return p.reject({ message: "Probably a network error, is the server down?", error });
        });
        if (options.timeout) {
          let timeout = new p(function(resolve, reject) {
            let timerId = setTimeout(function() {
              clearTimeout(timerId);
              return reject({ message: "Request timed out", timeout: options.timeout });
            }, options.timeout);
          });
          fetching = p.race([fetching, timeout]);
        }
        fetching.then(function(response) {
          if (response.ok) {
            if (typeof options.success === typeof Janus2.noop) {
              return response.json().then(function(parsed) {
                try {
                  options.success(parsed);
                } catch (error) {
                  Janus2.error("Unhandled httpAPICall success callback error", error);
                }
              }, function(error) {
                return p.reject({ message: "Failed to parse response body", error, response });
              });
            }
          } else {
            return p.reject({ message: "API call failed", response });
          }
        }).catch(function(error) {
          if (typeof options.error === typeof Janus2.noop) {
            options.error(error.message || "<< internal error >>", error);
          }
        });
        return fetching;
      }
    };
  };
  Janus2.useOldDependencies = function(deps) {
    let jq = deps && deps.jQuery || jQuery;
    let socketCls = deps && deps.WebSocket || WebSocket;
    return {
      newWebSocket: function(server, proto) {
        return new socketCls(server, proto);
      },
      isArray: function(arr) {
        return jq.isArray(arr);
      },
      extension: deps && deps.extension || defaultExtension,
      webRTCAdapter: deps && deps.adapter || adapter,
      httpAPICall: function(url, options) {
        let payload = typeof options.body !== "undefined" ? {
          contentType: "application/json",
          data: JSON.stringify(options.body)
        } : {};
        let credentials = typeof options.withCredentials !== "undefined" ? { xhrFields: { withCredentials: options.withCredentials } } : {};
        return jq.ajax(jq.extend(payload, credentials, {
          url,
          type: options.verb,
          cache: false,
          dataType: "json",
          async: options.async,
          timeout: options.timeout,
          success: function(result) {
            if (typeof options.success === typeof Janus2.noop) {
              options.success(result);
            }
          },
          // eslint-disable-next-line no-unused-vars
          error: function(xhr, status, err) {
            if (typeof options.error === typeof Janus2.noop) {
              options.error(status, err);
            }
          }
        }));
      }
    };
  };
  Janus2.mediaToTracks = function(media) {
    let tracks = [];
    if (!media) {
      tracks.push({ type: "audio", capture: true, recv: true });
      tracks.push({ type: "video", capture: true, recv: true });
    } else {
      if (!media.keepAudio && media.audio !== false && (typeof media.audio === "undefined" || media.audio || media.audioSend || media.audioRecv || media.addAudio || media.replaceAudio || media.removeAudio)) {
        let track = { type: "audio" };
        if (media.removeAudio) {
          track.remove = true;
        } else {
          if (media.addAudio)
            track.add = true;
          else if (media.replaceAudio)
            track.replace = true;
          if (media.audioSend !== false)
            track.capture = media.audio || true;
          if (media.audioRecv !== false)
            track.recv = true;
        }
        if (track.remove || track.capture || track.recv)
          tracks.push(track);
      }
      if (!media.keepVideo && media.video !== false && (typeof media.video === "undefined" || media.video || media.videoSend || media.videoRecv || media.addVideo || media.replaceVideo || media.removeVideo)) {
        let track = { type: "video" };
        if (media.removeVideo) {
          track.remove = true;
        } else {
          if (media.addVideo)
            track.add = true;
          else if (media.replaceVideo)
            track.replace = true;
          if (media.videoSend !== false) {
            track.capture = media.video || true;
            if (["screen", "window", "desktop"].includes(track.capture)) {
              track.type = "screen";
              track.capture = { video: {} };
              if (media.screenshareFrameRate)
                track.capture.frameRate = media.screenshareFrameRate;
              if (media.screenshareHeight)
                track.capture.height = media.screenshareHeight;
              if (media.screenshareWidth)
                track.capture.width = media.screenshareWidth;
            }
          }
          if (media.videoRecv !== false)
            track.recv = true;
        }
        if (track.remove || track.capture || track.recv)
          tracks.push(track);
      }
      if (media.data) {
        tracks.push({ type: "data" });
      }
    }
    return tracks;
  };
  Janus2.trackConstraints = function(track) {
    let constraints = {};
    if (!track || !track.capture)
      return constraints;
    if (track.type === "audio") {
      constraints.audio = track.capture;
    } else if (track.type === "video") {
      if ((track.simulcast || track.svc) && track.capture === true)
        track.capture = "hires";
      if (track.capture === true || typeof track.capture === "object") {
        constraints.video = track.capture;
      } else {
        let width = 0;
        let height = 0;
        if (track.capture === "lowres") {
          width = 320;
          height = 240;
        } else if (track.capture === "lowres-16:9") {
          width = 320;
          height = 180;
        } else if (track.capture === "hires" || track.capture === "hires-16:9" || track.capture === "hdres") {
          width = 1280;
          height = 720;
        } else if (track.capture === "fhdres") {
          width = 1920;
          height = 1080;
        } else if (track.capture === "4kres") {
          width = 3840;
          height = 2160;
        } else if (track.capture === "stdres") {
          width = 640;
          height = 480;
        } else if (track.capture === "stdres-16:9") {
          width = 640;
          height = 360;
        } else {
          Janus2.log("Default video setting is stdres 4:3");
          width = 640;
          height = 480;
        }
        constraints.video = {
          width: { ideal: width },
          height: { ideal: height }
        };
      }
    } else if (track.type === "screen") {
      constraints.video = track.capture;
    }
    return constraints;
  };
  Janus2.noop = function() {
  };
  Janus2.dataChanDefaultLabel = "JanusDataChannel";
  Janus2.endOfCandidates = null;
  Janus2.stopAllTracks = function(stream) {
    try {
      let tracks = stream.getTracks();
      for (let mst of tracks) {
        Janus2.log(mst);
        if (mst && mst.dontStop !== true) {
          mst.stop();
        }
      }
    } catch (e) {
    }
  };
  Janus2.init = function(options) {
    options = options || {};
    options.callback = typeof options.callback == "function" ? options.callback : Janus2.noop;
    if (Janus2.initDone) {
      options.callback();
    } else {
      if (typeof console.log == "undefined") {
        console.log = function() {
        };
      }
      Janus2.trace = Janus2.noop;
      Janus2.debug = Janus2.noop;
      Janus2.vdebug = Janus2.noop;
      Janus2.log = Janus2.noop;
      Janus2.warn = Janus2.noop;
      Janus2.error = Janus2.noop;
      if (options.debug === true || options.debug === "all") {
        Janus2.trace = console.trace.bind(console);
        Janus2.debug = console.debug.bind(console);
        Janus2.vdebug = console.debug.bind(console);
        Janus2.log = console.log.bind(console);
        Janus2.warn = console.warn.bind(console);
        Janus2.error = console.error.bind(console);
      } else if (Array.isArray(options.debug)) {
        for (let d of options.debug) {
          switch (d) {
            case "trace":
              Janus2.trace = console.trace.bind(console);
              break;
            case "debug":
              Janus2.debug = console.debug.bind(console);
              break;
            case "vdebug":
              Janus2.vdebug = console.debug.bind(console);
              break;
            case "log":
              Janus2.log = console.log.bind(console);
              break;
            case "warn":
              Janus2.warn = console.warn.bind(console);
              break;
            case "error":
              Janus2.error = console.error.bind(console);
              break;
          }
        }
      }
      Janus2.log("Initializing library");
      let usedDependencies = options.dependencies || Janus2.useDefaultDependencies();
      Janus2.isArray = usedDependencies.isArray;
      Janus2.webRTCAdapter = usedDependencies.webRTCAdapter;
      Janus2.httpAPICall = usedDependencies.httpAPICall;
      Janus2.newWebSocket = usedDependencies.newWebSocket;
      Janus2.extension = usedDependencies.extension;
      Janus2.extension.init();
      Janus2.listDevices = function(callback, config) {
        callback = typeof callback == "function" ? callback : Janus2.noop;
        if (!config)
          config = { audio: true, video: true };
        if (Janus2.isGetUserMediaAvailable()) {
          navigator.mediaDevices.getUserMedia(config).then(function(stream) {
            navigator.mediaDevices.enumerateDevices().then(function(devices) {
              Janus2.debug(devices);
              callback(devices);
              Janus2.stopAllTracks(stream);
            });
          }).catch(function(err) {
            Janus2.error(err);
            callback([]);
          });
        } else {
          Janus2.warn("navigator.mediaDevices unavailable");
          callback([]);
        }
      };
      Janus2.attachMediaStream = function(element, stream) {
        try {
          element.srcObject = stream;
        } catch (e) {
          try {
            element.src = URL.createObjectURL(stream);
          } catch (e2) {
            Janus2.error("Error attaching stream to element", e2);
          }
        }
      };
      Janus2.reattachMediaStream = function(to, from) {
        try {
          to.srcObject = from.srcObject;
        } catch (e) {
          try {
            to.src = from.src;
          } catch (e2) {
            Janus2.error("Error reattaching stream to element", e2);
          }
        }
      };
      let iOS = ["iPad", "iPhone", "iPod"].indexOf(navigator.platform) >= 0;
      let eventName = iOS ? "pagehide" : "beforeunload";
      let oldOBF = window["on" + eventName];
      window.addEventListener(eventName, function() {
        Janus2.log("Closing window");
        for (const [sessionId, session] of Janus2.sessions) {
          if (session && session.destroyOnUnload) {
            Janus2.log("Destroying session " + sessionId);
            session.destroy({ unload: true, notifyDestroyed: false });
          }
        }
        if (oldOBF && typeof oldOBF == "function") {
          oldOBF();
        }
      });
      Janus2.safariVp8 = false;
      Janus2.safariVp9 = false;
      if (Janus2.webRTCAdapter.browserDetails.browser === "safari" && Janus2.webRTCAdapter.browserDetails.version >= 605) {
        if (RTCRtpSender && RTCRtpSender.getCapabilities && RTCRtpSender.getCapabilities("video") && RTCRtpSender.getCapabilities("video").codecs && RTCRtpSender.getCapabilities("video").codecs.length) {
          for (let codec of RTCRtpSender.getCapabilities("video").codecs) {
            if (codec && codec.mimeType && codec.mimeType.toLowerCase() === "video/vp8") {
              Janus2.safariVp8 = true;
            } else if (codec && codec.mimeType && codec.mimeType.toLowerCase() === "video/vp9") {
              Janus2.safariVp9 = true;
            }
          }
          if (Janus2.safariVp8) {
            Janus2.log("This version of Safari supports VP8");
          } else {
            Janus2.warn("This version of Safari does NOT support VP8: if you're using a Technology Preview, try enabling the 'WebRTC VP8 codec' setting in the 'Experimental Features' Develop menu");
          }
        } else {
          let testpc = new RTCPeerConnection({});
          testpc.createOffer({ offerToReceiveVideo: true }).then(function(offer) {
            Janus2.safariVp8 = offer.sdp.indexOf("VP8") !== -1;
            Janus2.safariVp9 = offer.sdp.indexOf("VP9") !== -1;
            if (Janus2.safariVp8) {
              Janus2.log("This version of Safari supports VP8");
            } else {
              Janus2.warn("This version of Safari does NOT support VP8: if you're using a Technology Preview, try enabling the 'WebRTC VP8 codec' setting in the 'Experimental Features' Develop menu");
            }
            testpc.close();
            testpc = null;
          });
        }
      }
      Janus2.initDone = true;
      options.callback();
    }
  };
  Janus2.isWebrtcSupported = function() {
    return !!window.RTCPeerConnection;
  };
  Janus2.isGetUserMediaAvailable = function() {
    return navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
  };
  Janus2.randomString = function(len) {
    let charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let randomString = "";
    for (let i = 0; i < len; i++) {
      let randomPoz = Math.floor(Math.random() * charSet.length);
      randomString += charSet.charAt(randomPoz);
    }
    return randomString;
  };
  function Janus2(gatewayCallbacks) {
    gatewayCallbacks = gatewayCallbacks || {};
    gatewayCallbacks.success = typeof gatewayCallbacks.success == "function" ? gatewayCallbacks.success : Janus2.noop;
    gatewayCallbacks.error = typeof gatewayCallbacks.error == "function" ? gatewayCallbacks.error : Janus2.noop;
    gatewayCallbacks.destroyed = typeof gatewayCallbacks.destroyed == "function" ? gatewayCallbacks.destroyed : Janus2.noop;
    if (!Janus2.initDone) {
      gatewayCallbacks.error("Library not initialized");
      return {};
    }
    if (!Janus2.isWebrtcSupported()) {
      gatewayCallbacks.error("WebRTC not supported by this browser");
      return {};
    }
    Janus2.log("Library initialized: " + Janus2.initDone);
    if (!gatewayCallbacks.server) {
      gatewayCallbacks.error("Invalid server url");
      return {};
    }
    let websockets = false;
    let ws = null;
    let wsHandlers = {};
    let wsKeepaliveTimeoutId = null;
    let servers = null;
    let serversIndex = 0;
    let server = gatewayCallbacks.server;
    if (Janus2.isArray(server)) {
      Janus2.log("Multiple servers provided (" + server.length + "), will use the first that works");
      server = null;
      servers = gatewayCallbacks.server;
      Janus2.debug(servers);
    } else {
      if (server.indexOf("ws") === 0) {
        websockets = true;
        Janus2.log("Using WebSockets to contact Janus: " + server);
      } else {
        websockets = false;
        Janus2.log("Using REST API to contact Janus: " + server);
      }
    }
    let iceServers = gatewayCallbacks.iceServers || [{ urls: "stun:stun.l.google.com:19302" }];
    let iceTransportPolicy = gatewayCallbacks.iceTransportPolicy;
    let bundlePolicy = gatewayCallbacks.bundlePolicy;
    let withCredentials = false;
    if (typeof gatewayCallbacks.withCredentials !== "undefined" && gatewayCallbacks.withCredentials !== null)
      withCredentials = gatewayCallbacks.withCredentials === true;
    let maxev = 10;
    if (typeof gatewayCallbacks.max_poll_events !== "undefined" && gatewayCallbacks.max_poll_events !== null)
      maxev = gatewayCallbacks.max_poll_events;
    if (maxev < 1)
      maxev = 1;
    let token = null;
    if (typeof gatewayCallbacks.token !== "undefined" && gatewayCallbacks.token !== null)
      token = gatewayCallbacks.token;
    let apisecret = null;
    if (typeof gatewayCallbacks.apisecret !== "undefined" && gatewayCallbacks.apisecret !== null)
      apisecret = gatewayCallbacks.apisecret;
    this.destroyOnUnload = true;
    if (typeof gatewayCallbacks.destroyOnUnload !== "undefined" && gatewayCallbacks.destroyOnUnload !== null)
      this.destroyOnUnload = gatewayCallbacks.destroyOnUnload === true;
    let keepAlivePeriod = 25e3;
    if (typeof gatewayCallbacks.keepAlivePeriod !== "undefined" && gatewayCallbacks.keepAlivePeriod !== null)
      keepAlivePeriod = gatewayCallbacks.keepAlivePeriod;
    if (isNaN(keepAlivePeriod))
      keepAlivePeriod = 25e3;
    let longPollTimeout = 6e4;
    if (typeof gatewayCallbacks.longPollTimeout !== "undefined" && gatewayCallbacks.longPollTimeout !== null)
      longPollTimeout = gatewayCallbacks.longPollTimeout;
    if (isNaN(longPollTimeout))
      longPollTimeout = 6e4;
    function getMaxBitrates(simulcastMaxBitrates) {
      let maxBitrates = {
        high: 9e5,
        medium: 3e5,
        low: 1e5
      };
      if (typeof simulcastMaxBitrates !== "undefined" && simulcastMaxBitrates !== null) {
        if (simulcastMaxBitrates.high)
          maxBitrates.high = simulcastMaxBitrates.high;
        if (simulcastMaxBitrates.medium)
          maxBitrates.medium = simulcastMaxBitrates.medium;
        if (simulcastMaxBitrates.low)
          maxBitrates.low = simulcastMaxBitrates.low;
      }
      return maxBitrates;
    }
    let connected = false;
    let sessionId = null;
    let pluginHandles = /* @__PURE__ */ new Map();
    let that = this;
    let retries = 0;
    let transactions = /* @__PURE__ */ new Map();
    createSession(gatewayCallbacks);
    this.getServer = function() {
      return server;
    };
    this.isConnected = function() {
      return connected;
    };
    this.reconnect = function(callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      callbacks["reconnect"] = true;
      createSession(callbacks);
    };
    this.getSessionId = function() {
      return sessionId;
    };
    this.getInfo = function(callbacks) {
      getInfo(callbacks);
    };
    this.destroy = function(callbacks) {
      destroySession(callbacks);
    };
    this.attach = function(callbacks) {
      createHandle(callbacks);
    };
    function eventHandler() {
      if (sessionId == null)
        return;
      Janus2.debug("Long poll...");
      if (!connected) {
        Janus2.warn("Is the server down? (connected=false)");
        return;
      }
      let longpoll = server + "/" + sessionId + "?rid=" + (/* @__PURE__ */ new Date()).getTime();
      if (maxev)
        longpoll = longpoll + "&maxev=" + maxev;
      if (token)
        longpoll = longpoll + "&token=" + encodeURIComponent(token);
      if (apisecret)
        longpoll = longpoll + "&apisecret=" + encodeURIComponent(apisecret);
      Janus2.httpAPICall(longpoll, {
        verb: "GET",
        withCredentials,
        success: handleEvent,
        timeout: longPollTimeout,
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
          retries++;
          if (retries > 3) {
            connected = false;
            gatewayCallbacks.error("Lost connection to the server (is it down?)");
            return;
          }
          eventHandler();
        }
      });
    }
    function handleEvent(json, skipTimeout) {
      retries = 0;
      if (!websockets && typeof sessionId !== "undefined" && sessionId !== null && skipTimeout !== true)
        eventHandler();
      if (!websockets && Janus2.isArray(json)) {
        for (let i = 0; i < json.length; i++) {
          handleEvent(json[i], true);
        }
        return;
      }
      if (json["janus"] === "keepalive") {
        Janus2.vdebug("Got a keepalive on session " + sessionId);
        return;
      } else if (json["janus"] === "server_info") {
        Janus2.debug("Got info on the Janus instance");
        Janus2.debug(json);
        const transaction = json["transaction"];
        if (transaction) {
          const reportSuccess = transactions.get(transaction);
          if (reportSuccess)
            reportSuccess(json);
          transactions.delete(transaction);
        }
        return;
      } else if (json["janus"] === "ack") {
        Janus2.debug("Got an ack on session " + sessionId);
        Janus2.debug(json);
        const transaction = json["transaction"];
        if (transaction) {
          const reportSuccess = transactions.get(transaction);
          if (reportSuccess)
            reportSuccess(json);
          transactions.delete(transaction);
        }
        return;
      } else if (json["janus"] === "success") {
        Janus2.debug("Got a success on session " + sessionId);
        Janus2.debug(json);
        const transaction = json["transaction"];
        if (transaction) {
          const reportSuccess = transactions.get(transaction);
          if (reportSuccess)
            reportSuccess(json);
          transactions.delete(transaction);
        }
        return;
      } else if (json["janus"] === "trickle") {
        const sender = json["sender"];
        if (!sender) {
          Janus2.warn("Missing sender...");
          return;
        }
        const pluginHandle = pluginHandles.get(sender);
        if (!pluginHandle) {
          Janus2.debug("This handle is not attached to this session");
          return;
        }
        let candidate = json["candidate"];
        Janus2.debug("Got a trickled candidate on session " + sessionId);
        Janus2.debug(candidate);
        let config = pluginHandle.webrtcStuff;
        if (config.pc && config.remoteSdp) {
          Janus2.debug("Adding remote candidate:", candidate);
          if (!candidate || candidate.completed === true) {
            config.pc.addIceCandidate(Janus2.endOfCandidates);
          } else {
            config.pc.addIceCandidate(candidate);
          }
        } else {
          Janus2.debug("We didn't do setRemoteDescription (trickle got here before the offer?), caching candidate");
          if (!config.candidates)
            config.candidates = [];
          config.candidates.push(candidate);
          Janus2.debug(config.candidates);
        }
      } else if (json["janus"] === "webrtcup") {
        Janus2.debug("Got a webrtcup event on session " + sessionId);
        Janus2.debug(json);
        const sender = json["sender"];
        if (!sender) {
          Janus2.warn("Missing sender...");
          return;
        }
        const pluginHandle = pluginHandles.get(sender);
        if (!pluginHandle) {
          Janus2.debug("This handle is not attached to this session");
          return;
        }
        pluginHandle.webrtcState(true);
        return;
      } else if (json["janus"] === "hangup") {
        Janus2.debug("Got a hangup event on session " + sessionId);
        Janus2.debug(json);
        const sender = json["sender"];
        if (!sender) {
          Janus2.warn("Missing sender...");
          return;
        }
        const pluginHandle = pluginHandles.get(sender);
        if (!pluginHandle) {
          Janus2.debug("This handle is not attached to this session");
          return;
        }
        pluginHandle.webrtcState(false, json["reason"]);
        pluginHandle.hangup();
      } else if (json["janus"] === "detached") {
        Janus2.debug("Got a detached event on session " + sessionId);
        Janus2.debug(json);
        const sender = json["sender"];
        if (!sender) {
          Janus2.warn("Missing sender...");
          return;
        }
        const pluginHandle = pluginHandles.get(sender);
        if (!pluginHandle) {
          return;
        }
        pluginHandle.ondetached();
        pluginHandle.detach();
      } else if (json["janus"] === "media") {
        Janus2.debug("Got a media event on session " + sessionId);
        Janus2.debug(json);
        const sender = json["sender"];
        if (!sender) {
          Janus2.warn("Missing sender...");
          return;
        }
        const pluginHandle = pluginHandles.get(sender);
        if (!pluginHandle) {
          Janus2.debug("This handle is not attached to this session");
          return;
        }
        pluginHandle.mediaState(json["type"], json["receiving"], json["mid"]);
      } else if (json["janus"] === "slowlink") {
        Janus2.debug("Got a slowlink event on session " + sessionId);
        Janus2.debug(json);
        const sender = json["sender"];
        if (!sender) {
          Janus2.warn("Missing sender...");
          return;
        }
        const pluginHandle = pluginHandles.get(sender);
        if (!pluginHandle) {
          Janus2.debug("This handle is not attached to this session");
          return;
        }
        pluginHandle.slowLink(json["uplink"], json["lost"], json["mid"]);
      } else if (json["janus"] === "error") {
        Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
        Janus2.debug(json);
        let transaction = json["transaction"];
        if (transaction) {
          let reportSuccess = transactions.get(transaction);
          if (reportSuccess) {
            reportSuccess(json);
          }
          transactions.delete(transaction);
        }
        return;
      } else if (json["janus"] === "event") {
        Janus2.debug("Got a plugin event on session " + sessionId);
        Janus2.debug(json);
        const sender = json["sender"];
        if (!sender) {
          Janus2.warn("Missing sender...");
          return;
        }
        let plugindata = json["plugindata"];
        if (!plugindata) {
          Janus2.warn("Missing plugindata...");
          return;
        }
        Janus2.debug("  -- Event is coming from " + sender + " (" + plugindata["plugin"] + ")");
        let data = plugindata["data"];
        Janus2.debug(data);
        const pluginHandle = pluginHandles.get(sender);
        if (!pluginHandle) {
          Janus2.warn("This handle is not attached to this session");
          return;
        }
        let jsep = json["jsep"];
        if (jsep) {
          Janus2.debug("Handling SDP as well...");
          Janus2.debug(jsep);
        }
        let callback = pluginHandle.onmessage;
        if (callback) {
          Janus2.debug("Notifying application...");
          callback(data, jsep);
        } else {
          Janus2.debug("No provided notification callback");
        }
      } else if (json["janus"] === "timeout") {
        Janus2.error("Timeout on session " + sessionId);
        Janus2.debug(json);
        if (websockets) {
          ws.close(3504, "Gateway timeout");
        }
        return;
      } else {
        Janus2.warn("Unknown message/event  '" + json["janus"] + "' on session " + sessionId);
        Janus2.debug(json);
      }
    }
    function keepAlive() {
      if (!server || !websockets || !connected)
        return;
      wsKeepaliveTimeoutId = setTimeout(keepAlive, keepAlivePeriod);
      let request = { "janus": "keepalive", "session_id": sessionId, "transaction": Janus2.randomString(12) };
      if (token)
        request["token"] = token;
      if (apisecret)
        request["apisecret"] = apisecret;
      ws.send(JSON.stringify(request));
    }
    function createSession(callbacks) {
      let transaction = Janus2.randomString(12);
      let request = { "janus": "create", "transaction": transaction };
      if (callbacks["reconnect"]) {
        connected = false;
        request["janus"] = "claim";
        request["session_id"] = sessionId;
        if (ws) {
          ws.onopen = null;
          ws.onerror = null;
          ws.onclose = null;
          if (wsKeepaliveTimeoutId) {
            clearTimeout(wsKeepaliveTimeoutId);
            wsKeepaliveTimeoutId = null;
          }
        }
      }
      if (token)
        request["token"] = token;
      if (apisecret)
        request["apisecret"] = apisecret;
      if (!server && Janus2.isArray(servers)) {
        server = servers[serversIndex];
        if (server.indexOf("ws") === 0) {
          websockets = true;
          Janus2.log("Server #" + (serversIndex + 1) + ": trying WebSockets to contact Janus (" + server + ")");
        } else {
          websockets = false;
          Janus2.log("Server #" + (serversIndex + 1) + ": trying REST API to contact Janus (" + server + ")");
        }
      }
      if (websockets) {
        ws = Janus2.newWebSocket(server, "janus-protocol");
        wsHandlers = {
          "error": function() {
            Janus2.error("Error connecting to the Janus WebSockets server... " + server);
            if (Janus2.isArray(servers) && !callbacks["reconnect"]) {
              serversIndex++;
              if (serversIndex === servers.length) {
                callbacks.error("Error connecting to any of the provided Janus servers: Is the server down?");
                return;
              }
              server = null;
              setTimeout(function() {
                createSession(callbacks);
              }, 200);
              return;
            }
            callbacks.error("Error connecting to the Janus WebSockets server: Is the server down?");
          },
          "open": function() {
            transactions.set(transaction, function(json) {
              Janus2.debug(json);
              if (json["janus"] !== "success") {
                Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
                callbacks.error(json["error"].reason);
                return;
              }
              wsKeepaliveTimeoutId = setTimeout(keepAlive, keepAlivePeriod);
              connected = true;
              sessionId = json["session_id"] ? json["session_id"] : json.data["id"];
              if (callbacks["reconnect"]) {
                Janus2.log("Claimed session: " + sessionId);
              } else {
                Janus2.log("Created session: " + sessionId);
              }
              Janus2.sessions.set(sessionId, that);
              callbacks.success();
            });
            ws.send(JSON.stringify(request));
          },
          "message": function(event) {
            handleEvent(JSON.parse(event.data));
          },
          "close": function() {
            if (!server || !connected) {
              return;
            }
            connected = false;
            gatewayCallbacks.error("Lost connection to the server (is it down?)");
          }
        };
        for (let eventName in wsHandlers) {
          ws.addEventListener(eventName, wsHandlers[eventName]);
        }
        return;
      }
      Janus2.httpAPICall(server, {
        verb: "POST",
        withCredentials,
        body: request,
        success: function(json) {
          Janus2.debug(json);
          if (json["janus"] !== "success") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
            callbacks.error(json["error"].reason);
            return;
          }
          connected = true;
          sessionId = json["session_id"] ? json["session_id"] : json.data["id"];
          if (callbacks["reconnect"]) {
            Janus2.log("Claimed session: " + sessionId);
          } else {
            Janus2.log("Created session: " + sessionId);
          }
          Janus2.sessions.set(sessionId, that);
          eventHandler();
          callbacks.success();
        },
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
          if (Janus2.isArray(servers) && !callbacks["reconnect"]) {
            serversIndex++;
            if (serversIndex === servers.length) {
              callbacks.error("Error connecting to any of the provided Janus servers: Is the server down?");
              return;
            }
            server = null;
            setTimeout(function() {
              createSession(callbacks);
            }, 200);
            return;
          }
          if (errorThrown === "")
            callbacks.error(textStatus + ": Is the server down?");
          else if (errorThrown && errorThrown.error)
            callbacks.error(textStatus + ": " + errorThrown.error.message);
          else
            callbacks.error(textStatus + ": " + errorThrown);
        }
      });
    }
    function getInfo(callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      Janus2.log("Getting info on Janus instance");
      if (!connected) {
        Janus2.warn("Is the server down? (connected=false)");
        callbacks.error("Is the server down? (connected=false)");
        return;
      }
      let transaction = Janus2.randomString(12);
      let request = { "janus": "info", "transaction": transaction };
      if (token)
        request["token"] = token;
      if (apisecret)
        request["apisecret"] = apisecret;
      if (websockets) {
        transactions.set(transaction, function(json) {
          Janus2.log("Server info:");
          Janus2.debug(json);
          if (json["janus"] !== "server_info") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
          }
          callbacks.success(json);
        });
        ws.send(JSON.stringify(request));
        return;
      }
      Janus2.httpAPICall(server, {
        verb: "POST",
        withCredentials,
        body: request,
        success: function(json) {
          Janus2.log("Server info:");
          Janus2.debug(json);
          if (json["janus"] !== "server_info") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
          }
          callbacks.success(json);
        },
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
          if (errorThrown === "")
            callbacks.error(textStatus + ": Is the server down?");
          else
            callbacks.error(textStatus + ": " + errorThrown);
        }
      });
    }
    function destroySession(callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      let unload = callbacks.unload === true;
      let notifyDestroyed = true;
      if (typeof callbacks.notifyDestroyed !== "undefined" && callbacks.notifyDestroyed !== null)
        notifyDestroyed = callbacks.notifyDestroyed === true;
      let cleanupHandles = callbacks.cleanupHandles === true;
      Janus2.log("Destroying session " + sessionId + " (unload=" + unload + ")");
      if (!sessionId) {
        Janus2.warn("No session to destroy");
        callbacks.success();
        if (notifyDestroyed)
          gatewayCallbacks.destroyed();
        return;
      }
      if (cleanupHandles) {
        for (const handleId of pluginHandles.keys())
          destroyHandle(handleId, { noRequest: true });
      }
      if (!connected) {
        Janus2.warn("Is the server down? (connected=false)");
        sessionId = null;
        callbacks.success();
        return;
      }
      let request = { "janus": "destroy", "transaction": Janus2.randomString(12) };
      if (token)
        request["token"] = token;
      if (apisecret)
        request["apisecret"] = apisecret;
      if (unload) {
        if (websockets) {
          ws.onclose = null;
          ws.close();
          ws = null;
        } else {
          navigator.sendBeacon(server + "/" + sessionId, JSON.stringify(request));
        }
        Janus2.log("Destroyed session:");
        sessionId = null;
        connected = false;
        callbacks.success();
        if (notifyDestroyed)
          gatewayCallbacks.destroyed();
        return;
      }
      if (websockets) {
        request["session_id"] = sessionId;
        let unbindWebSocket = function() {
          for (let eventName in wsHandlers) {
            ws.removeEventListener(eventName, wsHandlers[eventName]);
          }
          ws.removeEventListener("message", onUnbindMessage);
          ws.removeEventListener("error", onUnbindError);
          if (wsKeepaliveTimeoutId) {
            clearTimeout(wsKeepaliveTimeoutId);
          }
          ws.close();
        };
        let onUnbindMessage = function(event) {
          let data = JSON.parse(event.data);
          if (data.session_id == request.session_id && data.transaction == request.transaction) {
            unbindWebSocket();
            callbacks.success();
            if (notifyDestroyed)
              gatewayCallbacks.destroyed();
          }
        };
        let onUnbindError = function() {
          unbindWebSocket();
          callbacks.error("Failed to destroy the server: Is the server down?");
          if (notifyDestroyed)
            gatewayCallbacks.destroyed();
        };
        ws.addEventListener("message", onUnbindMessage);
        ws.addEventListener("error", onUnbindError);
        if (ws.readyState === 1) {
          ws.send(JSON.stringify(request));
        } else {
          onUnbindError();
        }
        return;
      }
      Janus2.httpAPICall(server + "/" + sessionId, {
        verb: "POST",
        withCredentials,
        body: request,
        success: function(json) {
          Janus2.log("Destroyed session:");
          Janus2.debug(json);
          sessionId = null;
          connected = false;
          if (json["janus"] !== "success") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
          }
          callbacks.success();
          if (notifyDestroyed)
            gatewayCallbacks.destroyed();
        },
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
          sessionId = null;
          connected = false;
          callbacks.success();
          if (notifyDestroyed)
            gatewayCallbacks.destroyed();
        }
      });
    }
    function createHandle(callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      callbacks.dataChannelOptions = callbacks.dataChannelOptions || { ordered: true };
      callbacks.consentDialog = typeof callbacks.consentDialog == "function" ? callbacks.consentDialog : Janus2.noop;
      callbacks.connectionState = typeof callbacks.connectionState == "function" ? callbacks.connectionState : Janus2.noop;
      callbacks.iceState = typeof callbacks.iceState == "function" ? callbacks.iceState : Janus2.noop;
      callbacks.mediaState = typeof callbacks.mediaState == "function" ? callbacks.mediaState : Janus2.noop;
      callbacks.webrtcState = typeof callbacks.webrtcState == "function" ? callbacks.webrtcState : Janus2.noop;
      callbacks.slowLink = typeof callbacks.slowLink == "function" ? callbacks.slowLink : Janus2.noop;
      callbacks.onmessage = typeof callbacks.onmessage == "function" ? callbacks.onmessage : Janus2.noop;
      callbacks.onlocaltrack = typeof callbacks.onlocaltrack == "function" ? callbacks.onlocaltrack : Janus2.noop;
      callbacks.onremotetrack = typeof callbacks.onremotetrack == "function" ? callbacks.onremotetrack : Janus2.noop;
      callbacks.ondata = typeof callbacks.ondata == "function" ? callbacks.ondata : Janus2.noop;
      callbacks.ondataopen = typeof callbacks.ondataopen == "function" ? callbacks.ondataopen : Janus2.noop;
      callbacks.oncleanup = typeof callbacks.oncleanup == "function" ? callbacks.oncleanup : Janus2.noop;
      callbacks.ondetached = typeof callbacks.ondetached == "function" ? callbacks.ondetached : Janus2.noop;
      if (!connected) {
        Janus2.warn("Is the server down? (connected=false)");
        callbacks.error("Is the server down? (connected=false)");
        return;
      }
      let plugin = callbacks.plugin;
      if (!plugin) {
        Janus2.error("Invalid plugin");
        callbacks.error("Invalid plugin");
        return;
      }
      let opaqueId = callbacks.opaqueId;
      let loopIndex = callbacks.loopIndex;
      let handleToken = callbacks.token ? callbacks.token : token;
      let transaction = Janus2.randomString(12);
      let request = { "janus": "attach", "plugin": plugin, "opaque_id": opaqueId, "loop_index": loopIndex, "transaction": transaction };
      if (handleToken)
        request["token"] = handleToken;
      if (apisecret)
        request["apisecret"] = apisecret;
      if (websockets) {
        transactions.set(transaction, function(json) {
          Janus2.debug(json);
          if (json["janus"] !== "success") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
            callbacks.error("Ooops: " + json["error"].code + " " + json["error"].reason);
            return;
          }
          let handleId = json.data["id"];
          Janus2.log("Created handle: " + handleId);
          let pluginHandle = {
            session: that,
            plugin,
            id: handleId,
            token: handleToken,
            detached: false,
            webrtcStuff: {
              started: false,
              myStream: null,
              streamExternal: false,
              mySdp: null,
              mediaConstraints: null,
              pc: null,
              dataChannelOptions: callbacks.dataChannelOptions,
              dataChannel: {},
              dtmfSender: null,
              trickle: true,
              iceDone: false,
              bitrate: {}
            },
            getId: function() {
              return handleId;
            },
            getPlugin: function() {
              return plugin;
            },
            getVolume: function(mid, result) {
              return getVolume(handleId, mid, true, result);
            },
            getRemoteVolume: function(mid, result) {
              return getVolume(handleId, mid, true, result);
            },
            getLocalVolume: function(mid, result) {
              return getVolume(handleId, mid, false, result);
            },
            isAudioMuted: function(mid) {
              return isMuted(handleId, mid, false);
            },
            muteAudio: function(mid) {
              return mute(handleId, mid, false, true);
            },
            unmuteAudio: function(mid) {
              return mute(handleId, mid, false, false);
            },
            isVideoMuted: function(mid) {
              return isMuted(handleId, mid, true);
            },
            muteVideo: function(mid) {
              return mute(handleId, mid, true, true);
            },
            unmuteVideo: function(mid) {
              return mute(handleId, mid, true, false);
            },
            getBitrate: function(mid) {
              return getBitrate(handleId, mid);
            },
            setMaxBitrate: function(mid, bitrate) {
              return setBitrate(handleId, mid, bitrate);
            },
            send: function(callbacks2) {
              sendMessage(handleId, callbacks2);
            },
            data: function(callbacks2) {
              sendData(handleId, callbacks2);
            },
            dtmf: function(callbacks2) {
              sendDtmf(handleId, callbacks2);
            },
            consentDialog: callbacks.consentDialog,
            connectionState: callbacks.connectionState,
            iceState: callbacks.iceState,
            mediaState: callbacks.mediaState,
            webrtcState: callbacks.webrtcState,
            slowLink: callbacks.slowLink,
            onmessage: callbacks.onmessage,
            createOffer: function(callbacks2) {
              prepareWebrtc(handleId, true, callbacks2);
            },
            createAnswer: function(callbacks2) {
              prepareWebrtc(handleId, false, callbacks2);
            },
            handleRemoteJsep: function(callbacks2) {
              prepareWebrtcPeer(handleId, callbacks2);
            },
            replaceTracks: function(callbacks2) {
              replaceTracks(handleId, callbacks2);
            },
            getLocalTracks: function() {
              return getLocalTracks(handleId);
            },
            getRemoteTracks: function() {
              return getRemoteTracks(handleId);
            },
            onlocaltrack: callbacks.onlocaltrack,
            onremotetrack: callbacks.onremotetrack,
            ondata: callbacks.ondata,
            ondataopen: callbacks.ondataopen,
            oncleanup: callbacks.oncleanup,
            ondetached: callbacks.ondetached,
            hangup: function(sendRequest) {
              cleanupWebrtc(handleId, sendRequest === true);
            },
            detach: function(callbacks2) {
              destroyHandle(handleId, callbacks2);
            }
          };
          pluginHandles.set(handleId, pluginHandle);
          callbacks.success(pluginHandle);
        });
        request["session_id"] = sessionId;
        ws.send(JSON.stringify(request));
        return;
      }
      Janus2.httpAPICall(server + "/" + sessionId, {
        verb: "POST",
        withCredentials,
        body: request,
        success: function(json) {
          Janus2.debug(json);
          if (json["janus"] !== "success") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
            callbacks.error("Ooops: " + json["error"].code + " " + json["error"].reason);
            return;
          }
          let handleId = json.data["id"];
          Janus2.log("Created handle: " + handleId);
          let pluginHandle = {
            session: that,
            plugin,
            id: handleId,
            token: handleToken,
            detached: false,
            webrtcStuff: {
              started: false,
              myStream: null,
              streamExternal: false,
              mySdp: null,
              mediaConstraints: null,
              pc: null,
              dataChannelOptions: callbacks.dataChannelOptions,
              dataChannel: {},
              dtmfSender: null,
              trickle: true,
              iceDone: false,
              bitrate: {}
            },
            getId: function() {
              return handleId;
            },
            getPlugin: function() {
              return plugin;
            },
            getVolume: function(mid, result) {
              return getVolume(handleId, mid, true, result);
            },
            getRemoteVolume: function(mid, result) {
              return getVolume(handleId, mid, true, result);
            },
            getLocalVolume: function(mid, result) {
              return getVolume(handleId, mid, false, result);
            },
            isAudioMuted: function(mid) {
              return isMuted(handleId, mid, false);
            },
            muteAudio: function(mid) {
              return mute(handleId, mid, false, true);
            },
            unmuteAudio: function(mid) {
              return mute(handleId, mid, false, false);
            },
            isVideoMuted: function(mid) {
              return isMuted(handleId, mid, true);
            },
            muteVideo: function(mid) {
              return mute(handleId, mid, true, true);
            },
            unmuteVideo: function(mid) {
              return mute(handleId, mid, true, false);
            },
            getBitrate: function(mid) {
              return getBitrate(handleId, mid);
            },
            setMaxBitrate: function(mid, bitrate) {
              return setBitrate(handleId, mid, bitrate);
            },
            send: function(callbacks2) {
              sendMessage(handleId, callbacks2);
            },
            data: function(callbacks2) {
              sendData(handleId, callbacks2);
            },
            dtmf: function(callbacks2) {
              sendDtmf(handleId, callbacks2);
            },
            consentDialog: callbacks.consentDialog,
            connectionState: callbacks.connectionState,
            iceState: callbacks.iceState,
            mediaState: callbacks.mediaState,
            webrtcState: callbacks.webrtcState,
            slowLink: callbacks.slowLink,
            onmessage: callbacks.onmessage,
            createOffer: function(callbacks2) {
              prepareWebrtc(handleId, true, callbacks2);
            },
            createAnswer: function(callbacks2) {
              prepareWebrtc(handleId, false, callbacks2);
            },
            handleRemoteJsep: function(callbacks2) {
              prepareWebrtcPeer(handleId, callbacks2);
            },
            replaceTracks: function(callbacks2) {
              replaceTracks(handleId, callbacks2);
            },
            getLocalTracks: function() {
              return getLocalTracks(handleId);
            },
            getRemoteTracks: function() {
              return getRemoteTracks(handleId);
            },
            onlocaltrack: callbacks.onlocaltrack,
            onremotetrack: callbacks.onremotetrack,
            ondata: callbacks.ondata,
            ondataopen: callbacks.ondataopen,
            oncleanup: callbacks.oncleanup,
            ondetached: callbacks.ondetached,
            hangup: function(sendRequest) {
              cleanupWebrtc(handleId, sendRequest === true);
            },
            detach: function(callbacks2) {
              destroyHandle(handleId, callbacks2);
            }
          };
          pluginHandles.set(handleId, pluginHandle);
          callbacks.success(pluginHandle);
        },
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
          if (errorThrown === "")
            callbacks.error(textStatus + ": Is the server down?");
          else
            callbacks.error(textStatus + ": " + errorThrown);
        }
      });
    }
    function sendMessage(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      if (!connected) {
        Janus2.warn("Is the server down? (connected=false)");
        callbacks.error("Is the server down? (connected=false)");
        return;
      }
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        callbacks.error("Invalid handle");
        return;
      }
      let message = callbacks.message;
      let jsep = callbacks.jsep;
      let transaction = Janus2.randomString(12);
      let request = { "janus": "message", "body": message, "transaction": transaction };
      if (pluginHandle.token)
        request["token"] = pluginHandle.token;
      if (apisecret)
        request["apisecret"] = apisecret;
      if (jsep) {
        request.jsep = {
          type: jsep.type,
          sdp: jsep.sdp
        };
        if (jsep.e2ee)
          request.jsep.e2ee = true;
        if (jsep.rid_order === "hml" || jsep.rid_order === "lmh")
          request.jsep.rid_order = jsep.rid_order;
        if (jsep.force_relay)
          request.jsep.force_relay = true;
        let svc = null;
        let config = pluginHandle.webrtcStuff;
        if (config.pc) {
          let transceivers = config.pc.getTransceivers();
          if (transceivers && transceivers.length > 0) {
            for (let mindex in transceivers) {
              let tr = transceivers[mindex];
              if (tr && tr.sender && tr.sender.track && tr.sender.track.kind === "video") {
                let params = tr.sender.getParameters();
                if (params && params.encodings && params.encodings[0] && params.encodings[0].scalabilityMode) {
                  if (!svc)
                    svc = [];
                  svc.push({
                    mindex: parseInt(mindex),
                    mid: tr.mid,
                    svc: params.encodings[0].scalabilityMode
                  });
                }
              }
            }
          }
        }
        if (svc)
          request.jsep.svc = svc;
      }
      Janus2.debug("Sending message to plugin (handle=" + handleId + "):");
      Janus2.debug(request);
      if (websockets) {
        request["session_id"] = sessionId;
        request["handle_id"] = handleId;
        transactions.set(transaction, function(json) {
          Janus2.debug("Message sent!");
          Janus2.debug(json);
          if (json["janus"] === "success") {
            let plugindata = json["plugindata"];
            if (!plugindata) {
              Janus2.warn("Request succeeded, but missing plugindata...");
              callbacks.success();
              return;
            }
            Janus2.log("Synchronous transaction successful (" + plugindata["plugin"] + ")");
            let data = plugindata["data"];
            Janus2.debug(data);
            callbacks.success(data);
            return;
          } else if (json["janus"] !== "ack") {
            if (json["error"]) {
              Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
              callbacks.error(json["error"].code + " " + json["error"].reason);
            } else {
              Janus2.error("Unknown error");
              callbacks.error("Unknown error");
            }
            return;
          }
          callbacks.success();
        });
        ws.send(JSON.stringify(request));
        return;
      }
      Janus2.httpAPICall(server + "/" + sessionId + "/" + handleId, {
        verb: "POST",
        withCredentials,
        body: request,
        success: function(json) {
          Janus2.debug("Message sent!");
          Janus2.debug(json);
          if (json["janus"] === "success") {
            let plugindata = json["plugindata"];
            if (!plugindata) {
              Janus2.warn("Request succeeded, but missing plugindata...");
              callbacks.success();
              return;
            }
            Janus2.log("Synchronous transaction successful (" + plugindata["plugin"] + ")");
            let data = plugindata["data"];
            Janus2.debug(data);
            callbacks.success(data);
            return;
          } else if (json["janus"] !== "ack") {
            if (json["error"]) {
              Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
              callbacks.error(json["error"].code + " " + json["error"].reason);
            } else {
              Janus2.error("Unknown error");
              callbacks.error("Unknown error");
            }
            return;
          }
          callbacks.success();
        },
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
          callbacks.error(textStatus + ": " + errorThrown);
        }
      });
    }
    function sendTrickleCandidate(handleId, candidate) {
      if (!connected) {
        Janus2.warn("Is the server down? (connected=false)");
        return;
      }
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return;
      }
      let request = { "janus": "trickle", "candidate": candidate, "transaction": Janus2.randomString(12) };
      if (pluginHandle.token)
        request["token"] = pluginHandle.token;
      if (apisecret)
        request["apisecret"] = apisecret;
      Janus2.vdebug("Sending trickle candidate (handle=" + handleId + "):");
      Janus2.vdebug(request);
      if (websockets) {
        request["session_id"] = sessionId;
        request["handle_id"] = handleId;
        ws.send(JSON.stringify(request));
        return;
      }
      Janus2.httpAPICall(server + "/" + sessionId + "/" + handleId, {
        verb: "POST",
        withCredentials,
        body: request,
        success: function(json) {
          Janus2.vdebug("Candidate sent!");
          Janus2.vdebug(json);
          if (json["janus"] !== "ack") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
            return;
          }
        },
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
        }
      });
    }
    function createDataChannel(handleId, dclabel, dcprotocol, incoming, pendingData) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return;
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc) {
        Janus2.warn("Invalid PeerConnection");
        return;
      }
      let onDataChannelMessage = function(event) {
        Janus2.log("Received message on data channel:", event);
        let label = event.target.label;
        pluginHandle.ondata(event.data, label);
      };
      let onDataChannelStateChange = function(event) {
        Janus2.log("Received state change on data channel:", event);
        let label = event.target.label;
        let protocol = event.target.protocol;
        let dcState = config.dataChannel[label] ? config.dataChannel[label].readyState : "null";
        Janus2.log("State change on <" + label + "> data channel: " + dcState);
        if (dcState === "open") {
          if (config.dataChannel[label].pending && config.dataChannel[label].pending.length > 0) {
            Janus2.log("Sending pending messages on <" + label + ">:", config.dataChannel[label].pending.length);
            for (let data of config.dataChannel[label].pending) {
              Janus2.log("Sending data on data channel <" + label + ">");
              Janus2.debug(data);
              config.dataChannel[label].send(data);
            }
            config.dataChannel[label].pending = [];
          }
          pluginHandle.ondataopen(label, protocol);
        }
      };
      let onDataChannelError = function(error) {
        Janus2.error("Got error on data channel:", error);
      };
      if (!incoming) {
        let dcoptions = config.dataChannelOptions;
        if (dcprotocol)
          dcoptions.protocol = dcprotocol;
        config.dataChannel[dclabel] = config.pc.createDataChannel(dclabel, dcoptions);
      } else {
        config.dataChannel[dclabel] = incoming;
      }
      config.dataChannel[dclabel].onmessage = onDataChannelMessage;
      config.dataChannel[dclabel].onopen = onDataChannelStateChange;
      config.dataChannel[dclabel].onclose = onDataChannelStateChange;
      config.dataChannel[dclabel].onerror = onDataChannelError;
      config.dataChannel[dclabel].pending = [];
      if (pendingData)
        config.dataChannel[dclabel].pending.push(pendingData);
    }
    function sendData(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        callbacks.error("Invalid handle");
        return;
      }
      let config = pluginHandle.webrtcStuff;
      let data = callbacks.text || callbacks.data;
      if (!data) {
        Janus2.warn("Invalid data");
        callbacks.error("Invalid data");
        return;
      }
      let label = callbacks.label ? callbacks.label : Janus2.dataChanDefaultLabel;
      if (!config.dataChannel[label]) {
        createDataChannel(handleId, label, callbacks.protocol, false, data, callbacks.protocol);
        callbacks.success();
        return;
      }
      if (config.dataChannel[label].readyState !== "open") {
        config.dataChannel[label].pending.push(data);
        callbacks.success();
        return;
      }
      Janus2.log("Sending data on data channel <" + label + ">");
      Janus2.debug(data);
      config.dataChannel[label].send(data);
      callbacks.success();
    }
    function sendDtmf(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        callbacks.error("Invalid handle");
        return;
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.dtmfSender) {
        if (config.pc) {
          let senders = config.pc.getSenders();
          let audioSender = senders.find(function(sender) {
            return sender.track && sender.track.kind === "audio";
          });
          if (!audioSender) {
            Janus2.warn("Invalid DTMF configuration (no audio track)");
            callbacks.error("Invalid DTMF configuration (no audio track)");
            return;
          }
          config.dtmfSender = audioSender.dtmf;
          if (config.dtmfSender) {
            Janus2.log("Created DTMF Sender");
            config.dtmfSender.ontonechange = function(tone) {
              Janus2.debug("Sent DTMF tone: " + tone.tone);
            };
          }
        }
        if (!config.dtmfSender) {
          Janus2.warn("Invalid DTMF configuration");
          callbacks.error("Invalid DTMF configuration");
          return;
        }
      }
      let dtmf = callbacks.dtmf;
      if (!dtmf) {
        Janus2.warn("Invalid DTMF parameters");
        callbacks.error("Invalid DTMF parameters");
        return;
      }
      let tones = dtmf.tones;
      if (!tones) {
        Janus2.warn("Invalid DTMF string");
        callbacks.error("Invalid DTMF string");
        return;
      }
      let duration = typeof dtmf.duration === "number" ? dtmf.duration : 500;
      let gap = typeof dtmf.gap === "number" ? dtmf.gap : 50;
      Janus2.debug("Sending DTMF string " + tones + " (duration " + duration + "ms, gap " + gap + "ms)");
      config.dtmfSender.insertDTMF(tones, duration, gap);
      callbacks.success();
    }
    function destroyHandle(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      let noRequest = callbacks.noRequest === true;
      Janus2.log("Destroying handle " + handleId + " (only-locally=" + noRequest + ")");
      cleanupWebrtc(handleId);
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || pluginHandle.detached) {
        pluginHandles.delete(handleId);
        callbacks.success();
        return;
      }
      pluginHandle.detached = true;
      if (noRequest) {
        pluginHandles.delete(handleId);
        callbacks.success();
        return;
      }
      if (!connected) {
        Janus2.warn("Is the server down? (connected=false)");
        callbacks.error("Is the server down? (connected=false)");
        return;
      }
      let request = { "janus": "detach", "transaction": Janus2.randomString(12) };
      if (pluginHandle.token)
        request["token"] = pluginHandle.token;
      if (apisecret)
        request["apisecret"] = apisecret;
      if (websockets) {
        request["session_id"] = sessionId;
        request["handle_id"] = handleId;
        ws.send(JSON.stringify(request));
        pluginHandles.delete(handleId);
        callbacks.success();
        return;
      }
      Janus2.httpAPICall(server + "/" + sessionId + "/" + handleId, {
        verb: "POST",
        withCredentials,
        body: request,
        success: function(json) {
          Janus2.log("Destroyed handle:");
          Janus2.debug(json);
          if (json["janus"] !== "success") {
            Janus2.error("Ooops: " + json["error"].code + " " + json["error"].reason);
          }
          pluginHandles.delete(handleId);
          callbacks.success();
        },
        error: function(textStatus, errorThrown) {
          Janus2.error(textStatus + ":", errorThrown);
          pluginHandles.delete(handleId);
          callbacks.success();
        }
      });
    }
    function createPeerconnectionIfNeeded(handleId, callbacks) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        throw "Invalid handle";
      }
      let config = pluginHandle.webrtcStuff;
      if (config.pc) {
        return;
      }
      let pc_config = {
        iceServers,
        iceTransportPolicy,
        bundlePolicy
      };
      pc_config.sdpSemantics = "unified-plan";
      let insertableStreams = false;
      if (callbacks.tracks) {
        for (let track of callbacks.tracks) {
          if (track.transforms && (track.transforms.sender || track.transforms.receiver)) {
            insertableStreams = true;
            break;
          }
        }
      }
      if (callbacks.externalEncryption) {
        insertableStreams = true;
        config.externalEncryption = true;
      }
      if (RTCRtpSender && (RTCRtpSender.prototype.createEncodedStreams || RTCRtpSender.prototype.createEncodedAudioStreams && RTCRtpSender.prototype.createEncodedVideoStreams) && insertableStreams) {
        config.insertableStreams = true;
        pc_config.forceEncodedAudioInsertableStreams = true;
        pc_config.forceEncodedVideoInsertableStreams = true;
        pc_config.encodedInsertableStreams = true;
      }
      Janus2.log("Creating PeerConnection");
      config.pc = new RTCPeerConnection(pc_config);
      Janus2.debug(config.pc);
      if (config.pc.getStats) {
        config.volume = {};
        config.bitrate.value = "0 kbits/sec";
      }
      Janus2.log("Preparing local SDP and gathering candidates (trickle=" + config.trickle + ")");
      config.pc.onconnectionstatechange = function() {
        if (config.pc)
          pluginHandle.connectionState(config.pc.connectionState);
      };
      config.pc.oniceconnectionstatechange = function() {
        if (config.pc)
          pluginHandle.iceState(config.pc.iceConnectionState);
      };
      config.pc.onicecandidate = function(event) {
        if (!event.candidate || event.candidate.candidate && event.candidate.candidate.indexOf("endOfCandidates") > 0) {
          Janus2.log("End of candidates.");
          config.iceDone = true;
          if (config.trickle === true) {
            sendTrickleCandidate(handleId, { completed: true });
          } else {
            sendSDP(handleId, callbacks);
          }
        } else {
          let candidate = {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex
          };
          if (config.trickle === true) {
            sendTrickleCandidate(handleId, candidate);
          }
        }
      };
      config.pc.ontrack = function(event) {
        Janus2.log("Handling Remote Track", event);
        if (!event.streams)
          return;
        if (!event.track)
          return;
        let mid = event.transceiver ? event.transceiver.mid : event.track.id;
        try {
          if (event.transceiver && event.transceiver.mid && event.track.id) {
            if (!pluginHandle.mids)
              pluginHandle.mids = {};
            pluginHandle.mids[event.track.id] = event.transceiver.mid;
          }
          pluginHandle.onremotetrack(event.track, mid, true, { reason: "created" });
        } catch (e) {
          Janus2.error("Error calling onremotetrack", e);
        }
        if (event.track.onended)
          return;
        let trackMutedTimeoutId = null;
        Janus2.log("Adding onended callback to track:", event.track);
        event.track.onended = function(ev) {
          Janus2.log("Remote track removed:", ev);
          clearTimeout(trackMutedTimeoutId);
          let transceivers = config.pc ? config.pc.getTransceivers() : null;
          let transceiver = transceivers ? transceivers.find(
            (t) => t.receiver.track === ev.target
          ) : null;
          let mid2 = transceiver ? transceiver.mid : ev.target.id;
          if (mid2 === ev.target.id && pluginHandle.mids && pluginHandle.mids[event.track.id])
            mid2 = pluginHandle.mids[event.track.id];
          try {
            pluginHandle.onremotetrack(ev.target, mid2, false, { reason: "ended" });
          } catch (e) {
            Janus2.error("Error calling onremotetrack on removal", e);
          }
          delete pluginHandle.mids[event.track.id];
        };
        event.track.onmute = function(ev) {
          Janus2.log("Remote track muted:", ev);
          if (!trackMutedTimeoutId) {
            trackMutedTimeoutId = setTimeout(function() {
              Janus2.log("Removing remote track");
              let transceivers = config.pc ? config.pc.getTransceivers() : null;
              let transceiver = transceivers ? transceivers.find(
                (t) => t.receiver.track === ev.target
              ) : null;
              let mid2 = transceiver ? transceiver.mid : ev.target.id;
              if (mid2 === ev.target.id && pluginHandle.mids && pluginHandle.mids[event.track.id])
                mid2 = pluginHandle.mids[event.track.id];
              try {
                pluginHandle.onremotetrack(ev.target, mid2, false, { reason: "mute" });
              } catch (e) {
                Janus2.error("Error calling onremotetrack on mute", e);
              }
              trackMutedTimeoutId = null;
            }, 3 * 840);
          }
        };
        event.track.onunmute = function(ev) {
          Janus2.log("Remote track flowing again:", ev);
          if (trackMutedTimeoutId != null) {
            clearTimeout(trackMutedTimeoutId);
            trackMutedTimeoutId = null;
          } else {
            try {
              let transceivers = config.pc ? config.pc.getTransceivers() : null;
              let transceiver = transceivers ? transceivers.find(
                (t) => t.receiver.track === ev.target
              ) : null;
              let mid2 = transceiver ? transceiver.mid : ev.target.id;
              pluginHandle.onremotetrack(ev.target, mid2, true, { reason: "unmute" });
            } catch (e) {
              Janus2.error("Error calling onremotetrack on unmute", e);
            }
          }
        };
      };
    }
    async function prepareWebrtc(handleId, offer, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : webrtcError;
      let jsep = callbacks.jsep;
      if (offer && jsep) {
        Janus2.error("Provided a JSEP to a createOffer");
        callbacks.error("Provided a JSEP to a createOffer");
        return;
      } else if (!offer && (!jsep || !jsep.type || !jsep.sdp)) {
        Janus2.error("A valid JSEP is required for createAnswer");
        callbacks.error("A valid JSEP is required for createAnswer");
        return;
      }
      if (callbacks.media && !callbacks.tracks) {
        callbacks.tracks = Janus2.mediaToTracks(callbacks.media);
        if (callbacks.simulcast === true || callbacks.simulcast2 === true || callbacks.svc) {
          for (let track of callbacks.tracks) {
            if (track.type === "video") {
              if (callbacks.simulcast === true || callbacks.simulcast2 === true)
                track.simulcast = true;
              else if (callbacks.svc)
                track.svc = callbacks.svc;
              break;
            }
          }
        }
        Janus2.warn("Deprecated media object passed, use tracks instead. Automatically translated to:", callbacks.tracks);
      }
      if (callbacks.tracks && !Array.isArray(callbacks.tracks)) {
        Janus2.error("Tracks must be an array");
        callbacks.error("Tracks must be an array");
        return;
      }
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        callbacks.error("Invalid handle");
        return;
      }
      let config = pluginHandle.webrtcStuff;
      config.trickle = isTrickleEnabled(callbacks.trickle);
      try {
        createPeerconnectionIfNeeded(handleId, callbacks);
        if (offer) {
          await captureDevices(handleId, callbacks);
        }
        if (!jsep) {
          let offer2 = await createOffer(handleId, callbacks);
          callbacks.success(offer2);
        } else {
          await config.pc.setRemoteDescription(jsep);
          Janus2.log("Remote description accepted!");
          config.remoteSdp = jsep.sdp;
          if (config.candidates && config.candidates.length > 0) {
            for (let i = 0; i < config.candidates.length; i++) {
              let candidate = config.candidates[i];
              Janus2.debug("Adding remote candidate:", candidate);
              if (!candidate || candidate.completed === true) {
                config.pc.addIceCandidate(Janus2.endOfCandidates);
              } else {
                config.pc.addIceCandidate(candidate);
              }
            }
            config.candidates = [];
          }
          await captureDevices(handleId, callbacks);
          let answer = await createAnswer(handleId, callbacks);
          callbacks.success(answer);
        }
      } catch (err) {
        Janus2.error(err);
        callbacks.error(err);
      }
    }
    function prepareWebrtcPeer(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : webrtcError;
      callbacks.customizeSdp = typeof callbacks.customizeSdp == "function" ? callbacks.customizeSdp : Janus2.noop;
      let jsep = callbacks.jsep;
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        callbacks.error("Invalid handle");
        return;
      }
      let config = pluginHandle.webrtcStuff;
      if (jsep) {
        if (!config.pc) {
          Janus2.warn("Wait, no PeerConnection?? if this is an answer, use createAnswer and not handleRemoteJsep");
          callbacks.error("No PeerConnection: if this is an answer, use createAnswer and not handleRemoteJsep");
          return;
        }
        callbacks.customizeSdp(jsep);
        config.pc.setRemoteDescription(jsep).then(function() {
          Janus2.log("Remote description accepted!");
          config.remoteSdp = jsep.sdp;
          if (config.candidates && config.candidates.length > 0) {
            for (let i = 0; i < config.candidates.length; i++) {
              let candidate = config.candidates[i];
              Janus2.debug("Adding remote candidate:", candidate);
              if (!candidate || candidate.completed === true) {
                config.pc.addIceCandidate(Janus2.endOfCandidates);
              } else {
                config.pc.addIceCandidate(candidate);
              }
            }
            config.candidates = [];
          }
          callbacks.success();
        }, callbacks.error);
      } else {
        callbacks.error("Invalid JSEP");
      }
    }
    async function createOffer(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.customizeSdp = typeof callbacks.customizeSdp == "function" ? callbacks.customizeSdp : Janus2.noop;
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        throw "Invalid handle";
      }
      let config = pluginHandle.webrtcStuff;
      Janus2.log("Creating offer (iceDone=" + config.iceDone + ")");
      let mediaConstraints = {};
      let iceRestart = callbacks.iceRestart === true;
      if (iceRestart)
        mediaConstraints.iceRestart = true;
      Janus2.debug(mediaConstraints);
      let offer = await config.pc.createOffer(mediaConstraints);
      Janus2.debug(offer);
      let jsep = {
        type: "offer",
        sdp: offer.sdp
      };
      callbacks.customizeSdp(jsep);
      offer.sdp = jsep.sdp;
      Janus2.log("Setting local description");
      config.mySdp = {
        type: "offer",
        sdp: offer.sdp
      };
      await config.pc.setLocalDescription(offer);
      config.mediaConstraints = mediaConstraints;
      if (!config.iceDone && !config.trickle) {
        Janus2.log("Waiting for all candidates...");
        return null;
      }
      if (config.insertableStreams || config.externalEncryption)
        offer.e2ee = true;
      return offer;
    }
    async function createAnswer(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.customizeSdp = typeof callbacks.customizeSdp == "function" ? callbacks.customizeSdp : Janus2.noop;
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        throw "Invalid handle";
      }
      let config = pluginHandle.webrtcStuff;
      Janus2.log("Creating answer (iceDone=" + config.iceDone + ")");
      let answer = await config.pc.createAnswer();
      Janus2.debug(answer);
      let jsep = {
        type: "answer",
        sdp: answer.sdp
      };
      callbacks.customizeSdp(jsep);
      answer.sdp = jsep.sdp;
      Janus2.log("Setting local description");
      config.mySdp = {
        type: "answer",
        sdp: answer.sdp
      };
      await config.pc.setLocalDescription(answer);
      if (!config.iceDone && !config.trickle) {
        Janus2.log("Waiting for all candidates...");
        return null;
      }
      if (config.insertableStreams || config.externalEncryption)
        answer.e2ee = true;
      return answer;
    }
    function sendSDP(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle, not sending anything");
        return;
      }
      let config = pluginHandle.webrtcStuff;
      Janus2.log("Sending offer/answer SDP...");
      if (!config.mySdp) {
        Janus2.warn("Local SDP instance is invalid, not sending anything...");
        return;
      }
      config.mySdp = {
        type: config.pc.localDescription.type,
        sdp: config.pc.localDescription.sdp
      };
      if (config.trickle === false)
        config.mySdp["trickle"] = false;
      Janus2.debug(callbacks);
      config.sdpSent = true;
      callbacks.success(config.mySdp);
    }
    async function replaceTracks(handleId, callbacks) {
      callbacks = callbacks || {};
      callbacks.success = typeof callbacks.success == "function" ? callbacks.success : Janus2.noop;
      callbacks.error = typeof callbacks.error == "function" ? callbacks.error : Janus2.noop;
      if (callbacks.tracks && !Array.isArray(callbacks.tracks)) {
        Janus2.error("Tracks must be an array");
        callbacks.error("Tracks must be an array");
        return;
      }
      for (let track of callbacks.tracks) {
        if (track.add || !track.replace && !track.remove)
          track.replace = true;
      }
      try {
        await captureDevices(handleId, callbacks);
        callbacks.success();
      } catch (err) {
        Janus2.error(err);
        callbacks.error(err);
      }
    }
    async function captureDevices(handleId, callbacks) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle, not sending anything");
        throw "Invalid handle";
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc) {
        Janus2.warn("Invalid PeerConnection");
        throw "Invalid PeerConnection";
      }
      let tracks = callbacks.tracks;
      if (!tracks || !Array.isArray(tracks) || tracks.length === 0) {
        return;
      }
      let openedConsentDialog = false;
      let groups = {};
      for (let track of tracks) {
        delete track.gumGroup;
        if (!track.type || !["audio", "video"].includes(track.type))
          continue;
        if (!track.capture || track.capture instanceof MediaStreamTrack)
          continue;
        let group = track.group ? track.group : "default";
        if (!groups[group])
          groups[group] = {};
        if (groups[group][track.type])
          continue;
        track.gumGroup = group;
        groups[group][track.type] = track;
      }
      let keys = Object.keys(groups);
      for (let key of keys) {
        let group = groups[key];
        if (!group.audio || !group.video) {
          if (group.audio)
            delete group.audio.gumGroup;
          if (group.video)
            delete group.video.gumGroup;
          delete groups[key];
        }
      }
      let answer = callbacks.jsep ? true : false;
      for (let track of tracks) {
        if (!track.type) {
          Janus2.warn("Missing track type:", track);
          continue;
        }
        if (track.type === "data") {
          if (config.pc.ondatachannel) {
            Janus2.warn("Data channel exists already, not creating another one");
            continue;
          }
          Janus2.log("Creating default data channel");
          createDataChannel(handleId, Janus2.dataChanDefaultLabel, null, false);
          config.pc.ondatachannel = function(event) {
            Janus2.log("Data channel created by Janus:", event);
            createDataChannel(handleId, event.channel.label, event.channel.protocol, event.channel);
          };
          continue;
        }
        if ((typeof track.add === "undefined" || track.add === null) && (typeof track.remove === "undefined" || track.remove === null) && (typeof track.replace === "undefined" || track.replace === null)) {
          track.add = true;
        }
        if (track.add && track.remove || track.add && track.remove && track.replace) {
          Janus2.warn("Conflicting actions for track, ignoring:", track);
          continue;
        }
        if (track.add && track.replace) {
          Janus2.warn("Both add and replace provided, falling back to replace:", track);
          delete track.add;
        } else if (track.remove && track.replace) {
          Janus2.warn("Both remove and replace provided, falling back to remove:", track);
          delete track.replace;
        }
        let kind = track.type;
        if (track.type === "screen")
          kind = "video";
        let transceiver = null, sender = null;
        if (track.mid) {
          transceiver = config.pc.getTransceivers().find((t) => t.mid === track.mid && t.receiver.track.kind === kind);
        } else if (!track.add) {
          transceiver = config.pc.getTransceivers().find((t) => t.receiver.track.kind === kind);
        }
        if (track.replace || track.remove) {
          if (!transceiver) {
            Janus2.warn("Couldn't find a transceiver for track:", track);
            continue;
          }
          if (!transceiver.sender) {
            Janus2.warn("No sender in the transceiver for track:", track);
            continue;
          }
          sender = transceiver.sender;
        }
        if (answer && !transceiver) {
          transceiver = config.pc.getTransceivers().find((t) => t.receiver.track.kind === kind);
          if (!transceiver) {
            Janus2.warn("Couldn't find a transceiver for track:", track);
            continue;
          }
        }
        let nt = null, trackId = null;
        if (track.remove || track.replace) {
          Janus2.log("Removing track from PeerConnection", track);
          trackId = sender.track ? sender.track.id : null;
          await sender.replaceTrack(null);
          if (trackId && config.myStream) {
            let rt = null;
            if (kind === "audio" && config.myStream.getAudioTracks() && config.myStream.getAudioTracks().length) {
              for (let t of config.myStream.getAudioTracks()) {
                if (t.id === trackId) {
                  rt = t;
                  Janus2.log("Removing audio track:", rt);
                }
              }
            } else if (kind === "video" && config.myStream.getVideoTracks() && config.myStream.getVideoTracks().length) {
              for (let t of config.myStream.getVideoTracks()) {
                if (t.id === trackId) {
                  rt = t;
                  Janus2.log("Removing video track:", rt);
                }
              }
            }
            if (rt) {
              try {
                config.myStream.removeTrack(rt);
                pluginHandle.onlocaltrack(rt, false);
              } catch (e) {
                Janus2.error("Error calling onlocaltrack on removal for renegotiation", e);
              }
              if (rt.dontStop !== true) {
                try {
                  rt.stop();
                } catch (e) {
                }
              }
            }
          }
        }
        if (track.capture) {
          if (track.gumGroup && groups[track.gumGroup] && groups[track.gumGroup].stream) {
            let stream = groups[track.gumGroup].stream;
            nt = track.type === "audio" ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0];
            delete groups[track.gumGroup].stream;
            delete groups[track.gumGroup];
            delete track.gumGroup;
          } else if (track.capture instanceof MediaStreamTrack) {
            nt = track.capture;
          } else {
            if (!openedConsentDialog) {
              openedConsentDialog = true;
              pluginHandle.consentDialog(true);
            }
            let constraints = Janus2.trackConstraints(track), stream = null;
            if (track.type === "audio" || track.type === "video") {
              if (track.gumGroup) {
                let otherType = track.type === "audio" ? "video" : "audio";
                if (groups[track.gumGroup] && groups[track.gumGroup][otherType]) {
                  let otherTrack = groups[track.gumGroup][otherType];
                  let otherConstraints = Janus2.trackConstraints(otherTrack);
                  constraints[otherType] = otherConstraints[otherType];
                }
              }
              stream = await navigator.mediaDevices.getUserMedia(constraints);
              if (track.gumGroup && constraints.audio && constraints.video) {
                groups[track.gumGroup].stream = stream;
                delete track.gumGroup;
              }
            } else {
              stream = await navigator.mediaDevices.getDisplayMedia(constraints);
            }
            nt = track.type === "audio" ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0];
          }
          if (track.replace) {
            await sender.replaceTrack(nt);
            let newDirection = "sendrecv";
            if (track.recv === false || transceiver.direction === "inactive" || transceiver.direction === "sendonly")
              newDirection = "sendonly";
            if (transceiver.setDirection)
              transceiver.setDirection(newDirection);
            else
              transceiver.direction = newDirection;
          } else {
            if (!config.myStream)
              config.myStream = new MediaStream();
            if (kind === "audio" || !track.simulcast && !track.svc) {
              sender = config.pc.addTrack(nt, config.myStream);
              transceiver = config.pc.getTransceivers().find((t) => t.sender === sender);
            } else if (track.simulcast) {
              if (Janus2.webRTCAdapter.browserDetails.browser !== "firefox") {
                Janus2.log("Enabling rid-based simulcasting:", nt);
                let maxBitrates = getMaxBitrates(track.simulcastMaxBitrates);
                transceiver = config.pc.addTransceiver(nt, {
                  direction: "sendrecv",
                  streams: [config.myStream],
                  sendEncodings: track.sendEncodings || [
                    { rid: "h", active: true, scalabilityMode: "L1T2", maxBitrate: maxBitrates.high },
                    { rid: "m", active: true, scalabilityMode: "L1T2", maxBitrate: maxBitrates.medium, scaleResolutionDownBy: 2 },
                    { rid: "l", active: true, scalabilityMode: "L1T2", maxBitrate: maxBitrates.low, scaleResolutionDownBy: 4 }
                  ]
                });
              } else {
                Janus2.log("Enabling Simulcasting for Firefox (RID)");
                transceiver = config.pc.addTransceiver(nt, {
                  direction: "sendrecv",
                  streams: [config.myStream]
                });
                sender = transceiver ? transceiver.sender : null;
                if (sender) {
                  let parameters = sender.getParameters();
                  if (!parameters)
                    parameters = {};
                  let maxBitrates = getMaxBitrates(track.simulcastMaxBitrates);
                  parameters.encodings = track.sendEncodings || [
                    { rid: "h", active: true, maxBitrate: maxBitrates.high },
                    { rid: "m", active: true, maxBitrate: maxBitrates.medium, scaleResolutionDownBy: 2 },
                    { rid: "l", active: true, maxBitrate: maxBitrates.low, scaleResolutionDownBy: 4 }
                  ];
                  sender.setParameters(parameters);
                }
              }
            } else {
              Janus2.log("Enabling SVC (" + track.svc + "):", nt);
              transceiver = config.pc.addTransceiver(nt, {
                direction: "sendrecv",
                streams: [config.myStream],
                sendEncodings: [
                  { scalabilityMode: track.svc }
                ]
              });
            }
            if (!sender)
              sender = transceiver ? transceiver.sender : null;
            if (track.codec) {
              if (Janus2.webRTCAdapter.browserDetails.browser === "firefox") {
                Janus2.warn("setCodecPreferences not supported in Firefox, ignoring codec for track:", track);
              } else if (typeof track.codec !== "string") {
                Janus2.warn("Invalid codec value, ignoring for track:", track);
              } else {
                let mimeType = kind + "/" + track.codec.toLowerCase();
                let codecs = RTCRtpReceiver.getCapabilities(kind).codecs.filter(function(codec) {
                  return codec.mimeType.toLowerCase() === mimeType;
                });
                if (!codecs || codecs.length === 0) {
                  Janus2.warn("Codec not supported in this browser for this track, ignoring:", track);
                } else if (transceiver) {
                  try {
                    transceiver.setCodecPreferences(codecs);
                  } catch (err) {
                    Janus2.warn("Failed enforcing codec for this " + kind + " track:", err);
                  }
                }
              }
            }
            if (track.bitrate) {
              if (track.simulcast || track.svc) {
                Janus2.warn("Ignoring bitrate for simulcast/SVC track, use sendEncodings for that");
              } else if (isNaN(track.bitrate) || track.bitrate < 0) {
                Janus2.warn("Ignoring invalid bitrate for track:", track);
              } else if (sender) {
                let params = sender.getParameters();
                if (!params || !params.encodings || params.encodings.length === 0) {
                  Janus2.warn("No encodings in the sender parameters, ignoring bitrate for track:", track);
                } else {
                  params.encodings[0].maxBitrate = track.bitrate;
                  await sender.setParameters(params);
                }
              }
            }
            if (kind === "video" && track.framerate) {
              if (track.simulcast || track.svc) {
                Janus2.warn("Ignoring framerate for simulcast/SVC track, use sendEncodings for that");
              } else if (isNaN(track.framerate) || track.framerate < 0) {
                Janus2.warn("Ignoring invalid framerate for track:", track);
              } else if (sender) {
                let params = sender.getParameters();
                if (!params || !params.encodings || params.encodings.length === 0) {
                  Janus2.warn("No encodings in the sender parameters, ignoring framerate for track:", track);
                } else {
                  params.encodings[0].maxFramerate = track.framerate;
                  await sender.setParameters(params);
                }
              }
            }
            if (track.transforms) {
              if (sender && track.transforms.sender) {
                let senderStreams = null;
                if (RTCRtpSender.prototype.createEncodedStreams) {
                  senderStreams = sender.createEncodedStreams();
                } else if (RTCRtpSender.prototype.createAudioEncodedStreams || RTCRtpSender.prototype.createEncodedVideoStreams) {
                  if (kind === "audio") {
                    senderStreams = sender.createEncodedAudioStreams();
                  } else if (kind === "video") {
                    senderStreams = sender.createEncodedVideoStreams();
                  }
                }
                if (senderStreams) {
                  if (senderStreams.readableStream && senderStreams.writableStream) {
                    senderStreams.readableStream.pipeThrough(track.transforms.sender).pipeTo(senderStreams.writableStream);
                  } else if (senderStreams.readable && senderStreams.writable) {
                    senderStreams.readable.pipeThrough(track.transforms.sender).pipeTo(senderStreams.writable);
                  }
                }
              }
              if (transceiver && transceiver.receiver && track.transforms.receiver) {
                let receiverStreams = null;
                if (RTCRtpReceiver.prototype.createEncodedStreams) {
                  receiverStreams = transceiver.receiver.createEncodedStreams();
                } else if (RTCRtpReceiver.prototype.createAudioEncodedStreams || RTCRtpReceiver.prototype.createEncodedVideoStreams) {
                  if (kind === "audio") {
                    receiverStreams = transceiver.receiver.createEncodedAudioStreams();
                  } else if (kind === "video") {
                    receiverStreams = transceiver.receiver.createEncodedVideoStreams();
                  }
                }
                if (receiverStreams) {
                  if (receiverStreams.readableStream && receiverStreams.writableStream) {
                    receiverStreams.readableStream.pipeThrough(track.transforms.receiver).pipeTo(receiverStreams.writableStream);
                  } else if (receiverStreams.readable && receiverStreams.writable) {
                    receiverStreams.readable.pipeThrough(track.transforms.receiver).pipeTo(receiverStreams.writable);
                  }
                }
              }
            }
          }
          if (nt && track.dontStop === true)
            nt.dontStop = true;
        } else if (track.recv) {
          if (!transceiver)
            transceiver = config.pc.addTransceiver(kind);
          if (transceiver) {
            if (track.codec) {
              if (Janus2.webRTCAdapter.browserDetails.browser === "firefox") {
                Janus2.warn("setCodecPreferences not supported in Firefox, ignoring codec for track:", track);
              } else if (typeof track.codec !== "string") {
                Janus2.warn("Invalid codec value, ignoring for track:", track);
              } else {
                let mimeType = kind + "/" + track.codec.toLowerCase();
                let codecs = RTCRtpReceiver.getCapabilities(kind).codecs.filter(function(codec) {
                  return codec.mimeType.toLowerCase() === mimeType;
                });
                if (!codecs || codecs.length === 0) {
                  Janus2.warn("Codec not supported in this browser for this track, ignoring:", track);
                } else {
                  try {
                    transceiver.setCodecPreferences(codecs);
                  } catch (err) {
                    Janus2.warn("Failed enforcing codec for this " + kind + " track:", err);
                  }
                }
              }
            }
            if (transceiver.receiver && track.transforms && track.transforms.receiver) {
              let receiverStreams = null;
              if (RTCRtpReceiver.prototype.createEncodedStreams) {
                receiverStreams = transceiver.receiver.createEncodedStreams();
              } else if (RTCRtpReceiver.prototype.createAudioEncodedStreams || RTCRtpReceiver.prototype.createEncodedVideoStreams) {
                if (kind === "audio") {
                  receiverStreams = transceiver.receiver.createEncodedAudioStreams();
                } else if (kind === "video") {
                  receiverStreams = transceiver.receiver.createEncodedVideoStreams();
                }
              }
              if (receiverStreams) {
                if (receiverStreams.readableStream && receiverStreams.writableStream) {
                  receiverStreams.readableStream.pipeThrough(track.transforms.receiver).pipeTo(receiverStreams.writableStream);
                } else if (receiverStreams.readable && receiverStreams.writable) {
                  receiverStreams.readable.pipeThrough(track.transforms.receiver).pipeTo(receiverStreams.writable);
                }
              }
            }
          }
        }
        if (nt) {
          config.myStream.addTrack(nt);
          nt.onended = function(ev) {
            Janus2.log("Local track removed:", ev);
            try {
              pluginHandle.onlocaltrack(ev.target, false);
            } catch (e) {
              Janus2.error("Error calling onlocaltrack following end", e);
            }
          };
          try {
            pluginHandle.onlocaltrack(nt, true);
          } catch (e) {
            Janus2.error("Error calling onlocaltrack for track add", e);
          }
        }
        if (transceiver) {
          let curdir = transceiver.direction, newdir = null;
          let send = nt && transceiver.sender.track, recv = track.recv !== false && transceiver.receiver.track;
          if (send && recv)
            newdir = "sendrecv";
          else if (send && !recv)
            newdir = "sendonly";
          else if (!send && recv)
            newdir = "recvonly";
          else if (!send && !recv)
            newdir = "inactive";
          if (newdir && newdir !== curdir) {
            Janus2.warn("Changing direction of transceiver to " + newdir + " (was " + curdir + ")", track);
            if (transceiver.setDirection)
              transceiver.setDirection(newdir);
            else
              transceiver.direction = newdir;
          }
        }
      }
      if (openedConsentDialog)
        pluginHandle.consentDialog(false);
    }
    function getLocalTracks(handleId) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return null;
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc) {
        Janus2.warn("Invalid PeerConnection");
        return null;
      }
      let tracks = [];
      let transceivers = config.pc.getTransceivers();
      for (let tr of transceivers) {
        let track = null;
        if (tr.sender && tr.sender.track) {
          track = { mid: tr.mid };
          track.type = tr.sender.track.kind;
          track.id = tr.sender.track.id;
          track.label = tr.sender.track.label;
        }
        if (track)
          tracks.push(track);
      }
      return tracks;
    }
    function getRemoteTracks(handleId) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return null;
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc) {
        Janus2.warn("Invalid PeerConnection");
        return null;
      }
      let tracks = [];
      let transceivers = config.pc.getTransceivers();
      for (let tr of transceivers) {
        let track = null;
        if (tr.receiver && tr.receiver.track) {
          track = { mid: tr.mid };
          track.type = tr.receiver.track.kind;
          track.id = tr.receiver.track.id;
          track.label = tr.receiver.track.label;
        }
        if (track)
          tracks.push(track);
      }
      return tracks;
    }
    function getVolume(handleId, mid, remote, result) {
      result = typeof result == "function" ? result : Janus2.noop;
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        result(0);
        return;
      }
      let stream = remote ? "remote" : "local";
      let config = pluginHandle.webrtcStuff;
      if (!config.volume[stream])
        config.volume[stream] = { value: 0 };
      if (config.pc && config.pc.getStats && (Janus2.webRTCAdapter.browserDetails.browser === "chrome" || Janus2.webRTCAdapter.browserDetails.browser === "safari")) {
        let query = config.pc;
        if (mid) {
          let transceiver = config.pc.getTransceivers().find((t) => t.mid === mid && t.receiver.track.kind === "audio");
          if (!transceiver) {
            Janus2.warn("No audio transceiver with mid " + mid);
            result(0);
            return;
          }
          if (remote && !transceiver.receiver) {
            Janus2.warn("Remote transceiver track unavailable");
            result(0);
            return;
          } else if (!remote && !transceiver.sender) {
            Janus2.warn("Local transceiver track unavailable");
            result(0);
            return;
          }
          query = remote ? transceiver.receiver : transceiver.sender;
        }
        query.getStats().then(function(stats) {
          stats.forEach(function(res) {
            if (!res || res.kind !== "audio")
              return;
            if (remote && !res.remoteSource || !remote && res.type !== "media-source")
              return;
            result(res.audioLevel ? res.audioLevel : 0);
          });
        });
        return config.volume[stream].value;
      } else {
        Janus2.warn("Getting the " + stream + " volume unsupported by browser");
        result(0);
        return;
      }
    }
    function isMuted(handleId, mid, video) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return true;
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc) {
        Janus2.warn("Invalid PeerConnection");
        return true;
      }
      if (!config.myStream) {
        Janus2.warn("Invalid local MediaStream");
        return true;
      }
      if (video) {
        if (!config.myStream.getVideoTracks() || config.myStream.getVideoTracks().length === 0) {
          Janus2.warn("No video track");
          return true;
        }
        if (mid) {
          let transceiver = config.pc.getTransceivers().find((t) => t.mid === mid && t.receiver.track.kind === "video");
          if (!transceiver) {
            Janus2.warn("No video transceiver with mid " + mid);
            return true;
          }
          if (!transceiver.sender || !transceiver.sender.track) {
            Janus2.warn("No video sender with mid " + mid);
            return true;
          }
          return !transceiver.sender.track.enabled;
        } else {
          return !config.myStream.getVideoTracks()[0].enabled;
        }
      } else {
        if (!config.myStream.getAudioTracks() || config.myStream.getAudioTracks().length === 0) {
          Janus2.warn("No audio track");
          return true;
        }
        if (mid) {
          let transceiver = config.pc.getTransceivers().find((t) => t.mid === mid && t.receiver.track.kind === "audio");
          if (!transceiver) {
            Janus2.warn("No audio transceiver with mid " + mid);
            return true;
          }
          if (!transceiver.sender || !transceiver.sender.track) {
            Janus2.warn("No audio sender with mid " + mid);
            return true;
          }
          return !transceiver.sender.track.enabled;
        } else {
          return !config.myStream.getAudioTracks()[0].enabled;
        }
      }
    }
    function mute(handleId, mid, video, mute2) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return false;
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc) {
        Janus2.warn("Invalid PeerConnection");
        return false;
      }
      if (!config.myStream) {
        Janus2.warn("Invalid local MediaStream");
        return false;
      }
      if (video) {
        if (!config.myStream.getVideoTracks() || config.myStream.getVideoTracks().length === 0) {
          Janus2.warn("No video track");
          return false;
        }
        if (mid) {
          let transceiver = config.pc.getTransceivers().find((t) => t.mid === mid && t.receiver.track.kind === "video");
          if (!transceiver) {
            Janus2.warn("No video transceiver with mid " + mid);
            return false;
          }
          if (!transceiver.sender || !transceiver.sender.track) {
            Janus2.warn("No video sender with mid " + mid);
            return false;
          }
          transceiver.sender.track.enabled = mute2 ? false : true;
        } else {
          for (const videostream of config.myStream.getVideoTracks()) {
            videostream.enabled = !mute2;
          }
        }
      } else {
        if (!config.myStream.getAudioTracks() || config.myStream.getAudioTracks().length === 0) {
          Janus2.warn("No audio track");
          return false;
        }
        if (mid) {
          let transceiver = config.pc.getTransceivers().find((t) => t.mid === mid && t.receiver.track.kind === "audio");
          if (!transceiver) {
            Janus2.warn("No audio transceiver with mid " + mid);
            return false;
          }
          if (!transceiver.sender || !transceiver.sender.track) {
            Janus2.warn("No audio sender with mid " + mid);
            return false;
          }
          transceiver.sender.track.enabled = mute2 ? false : true;
        } else {
          for (const audiostream of config.myStream.getAudioTracks()) {
            audiostream.enabled = !mute2;
          }
        }
      }
      return true;
    }
    function getBitrate(handleId, mid) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return "Invalid handle";
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc)
        return "Invalid PeerConnection";
      if (config.pc.getStats) {
        let query = config.pc;
        let target = mid ? mid : "default";
        if (mid) {
          let transceiver = config.pc.getTransceivers().find((t) => t.mid === mid && t.receiver.track.kind === "video");
          if (!transceiver) {
            Janus2.warn("No video transceiver with mid " + mid);
            return "No video transceiver with mid " + mid;
          }
          if (!transceiver.receiver) {
            Janus2.warn("No video receiver with mid " + mid);
            return "No video receiver with mid " + mid;
          }
          query = transceiver.receiver;
        }
        if (!config.bitrate[target]) {
          config.bitrate[target] = {
            timer: null,
            bsnow: null,
            bsbefore: null,
            tsnow: null,
            tsbefore: null,
            value: "0 kbits/sec"
          };
        }
        if (!config.bitrate[target].timer) {
          Janus2.log("Starting bitrate timer" + (mid ? " for mid " + mid : "") + " (via getStats)");
          config.bitrate[target].timer = setInterval(function() {
            query.getStats().then(function(stats) {
              stats.forEach(function(res) {
                if (!res)
                  return;
                let inStats = false;
                if ((res.mediaType === "video" || res.kind === "video" || res.id.toLowerCase().indexOf("video") > -1) && res.type === "inbound-rtp" && res.id.indexOf("rtcp") < 0) {
                  inStats = true;
                } else if (res.type == "ssrc" && res.bytesReceived && (res.googCodecName === "VP8" || res.googCodecName === "")) {
                  inStats = true;
                }
                if (inStats) {
                  config.bitrate[target].bsnow = res.bytesReceived;
                  config.bitrate[target].tsnow = res.timestamp;
                  if (config.bitrate[target].bsbefore === null || config.bitrate[target].tsbefore === null) {
                    config.bitrate[target].bsbefore = config.bitrate[target].bsnow;
                    config.bitrate[target].tsbefore = config.bitrate[target].tsnow;
                  } else {
                    let timePassed = config.bitrate[target].tsnow - config.bitrate[target].tsbefore;
                    if (Janus2.webRTCAdapter.browserDetails.browser === "safari")
                      timePassed = timePassed / 1e3;
                    let bitRate = Math.round((config.bitrate[target].bsnow - config.bitrate[target].bsbefore) * 8 / timePassed);
                    if (Janus2.webRTCAdapter.browserDetails.browser === "safari")
                      bitRate = parseInt(bitRate / 1e3);
                    config.bitrate[target].value = bitRate + " kbits/sec";
                    config.bitrate[target].bsbefore = config.bitrate[target].bsnow;
                    config.bitrate[target].tsbefore = config.bitrate[target].tsnow;
                  }
                }
              });
            });
          }, 1e3);
          return "0 kbits/sec";
        }
        return config.bitrate[target].value;
      } else {
        Janus2.warn("Getting the video bitrate unsupported by browser");
        return "Feature unsupported by browser";
      }
    }
    function setBitrate(handleId, mid, bitrate) {
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle || !pluginHandle.webrtcStuff) {
        Janus2.warn("Invalid handle");
        return;
      }
      let config = pluginHandle.webrtcStuff;
      if (!config.pc) {
        Janus2.warn("Invalid PeerConnection");
        return;
      }
      let transceiver = config.pc.getTransceivers().find((t) => t.mid === mid);
      if (!transceiver) {
        Janus2.warn("No transceiver with mid", mid);
        return;
      }
      if (!transceiver.sender) {
        Janus2.warn("No sender for transceiver with mid", mid);
        return;
      }
      let params = transceiver.sender.getParameters();
      if (!params || !params.encodings || params.encodings.length === 0) {
        Janus2.warn("No parameters encodings");
      } else if (params.encodings.length > 1) {
        Janus2.warn("Ignoring bitrate for simulcast track, use sendEncodings for that");
      } else if (isNaN(bitrate) || bitrate < 0) {
        Janus2.warn("Invalid bitrate (must be a positive integer)");
      } else {
        params.encodings[0].maxBitrate = bitrate;
        transceiver.sender.setParameters(params);
      }
    }
    function webrtcError(error) {
      Janus2.error("WebRTC error:", error);
    }
    function cleanupWebrtc(handleId, hangupRequest) {
      Janus2.log("Cleaning WebRTC stuff");
      let pluginHandle = pluginHandles.get(handleId);
      if (!pluginHandle) {
        return;
      }
      let config = pluginHandle.webrtcStuff;
      if (config) {
        if (hangupRequest === true) {
          let request = { "janus": "hangup", "transaction": Janus2.randomString(12) };
          if (pluginHandle.token)
            request["token"] = pluginHandle.token;
          if (apisecret)
            request["apisecret"] = apisecret;
          Janus2.debug("Sending hangup request (handle=" + handleId + "):");
          Janus2.debug(request);
          if (websockets) {
            request["session_id"] = sessionId;
            request["handle_id"] = handleId;
            ws.send(JSON.stringify(request));
          } else {
            Janus2.httpAPICall(server + "/" + sessionId + "/" + handleId, {
              verb: "POST",
              withCredentials,
              body: request
            });
          }
        }
        if (config.volume) {
          if (config.volume["local"] && config.volume["local"].timer)
            clearInterval(config.volume["local"].timer);
          if (config.volume["remote"] && config.volume["remote"].timer)
            clearInterval(config.volume["remote"].timer);
        }
        for (let i in config.bitrate) {
          if (config.bitrate[i].timer)
            clearInterval(config.bitrate[i].timer);
        }
        config.bitrate = {};
        if (!config.streamExternal && config.myStream) {
          Janus2.log("Stopping local stream tracks");
          Janus2.stopAllTracks(config.myStream);
        }
        config.streamExternal = false;
        config.myStream = null;
        try {
          config.pc.close();
        } catch (e) {
        }
        config.pc = null;
        config.candidates = null;
        config.mySdp = null;
        config.remoteSdp = null;
        config.iceDone = false;
        config.dataChannel = {};
        config.dtmfSender = null;
        config.insertableStreams = false;
        config.externalEncryption = false;
      }
      pluginHandle.oncleanup();
    }
    function isTrickleEnabled(trickle) {
      Janus2.debug("isTrickleEnabled:", trickle);
      return trickle === false ? false : true;
    }
  }
  return Janus2;
});
export {
  Janus as default
};
//# sourceMappingURL=janus-gateway.js.map
